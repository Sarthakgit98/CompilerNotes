# Lecture 6

Entering chapter 3 of book, register allocation

We want to make sure most of the times our variables are using registers, rather than memory because they are faster.

Register allocation/mapping: Assigning memory locations to register

## System V ABI

We will be following System V ABI for calling conventions of x86 when making our compiler, look up System V ABI on wikipedia, x86-64 section.

## Calling conventions

When we call some function foo, it will execute a piece of code somewhere else. When doing that, what registers should be used for temporary or passing purposes, or what should store the return value, or how should pre-call state be restored etc etc is defined by certain conventions.

Callee save registers: Registers whose values remain unchanged across calls
Caller save registers: Registers whose values can change across calls

What are caller save and callee save registers is defined by conventions.

Example (straight from book),

> (let ([x (read)])
	(let ([y (read)])
		(+ (+ x y) 42)))
		

Generated x86 code,

start:
	callq read_int
	movq %rax, %rbx ---> rbx is callee-saved because we want this number to be preserved even despite next function call.
	callq read_int ---> Here, rbx is call-live. Because this register stores a value, and this value is needed later despite this function call. We want it preserved so we did the movq in the previous line.
	movq %rax, %rcx ---> rcx is caller-saved. We don't need to worry about this being overwritten because there are no further calls beyond this. rcx is also not call-live. So it does not need to be a callee-saved register.
	addq %rcx, %rbx
	movq %rbx, %rax
	addq $42, %rax
	jmp _conclusion
	
	.globl main
main:
	pushq %rbp 
	movq %rsp, %rbp
	pushq %rbx 
	subq $8, %rsp ---> To make it 16-byte aligned. The 8 is pre-calculated by compiler to generate this line.
	jmp start
conclusion:
	addq $8, %rsp ---> Same as previous commented line, this was also generated by precalculating the 8.
	popq %rbx
	popq %rbp
	retq
	
	
	
## Liveness analysis

Reference x86-var example,

```
1. movq $5, a
2. movq $30, b
3. movq a, c
4. movq $10, b
5. addq b, c
```

Interference diag,

3.a -> 1.a
5.b -> 4.b
5.c -> 3.c
Here, we can use same register for both a and b. Their arrows will not overlap.

Keeping above arrows in mind, we maintain sets across each line. These sets contain variables whose values need to be preserved.

```
1. movq $5, a		{}
2. movq $30, b		{a}
3. movq a, c		{a}
4. movq $10, b		{c}
5. addq b, c		{b, c}
```



